import { Express } from 'express'
import { ApolloServer } from 'apollo-server-express'
import { DocumentNode, GraphQLSchema } from 'graphql'
import { mergeTypeDefs, mergeResolvers } from '@graphql-tools/merge'
import { jsonToSchema } from '@walmartlabs/json-to-simple-graphql-schema'

import { DB } from './db'
import { Server } from './server'
import { Klass } from './types'
import { toPascalCase, toCamelCase } from './shared'
import { Source, Sink } from './interfaces'

export type Input = {
  types: string | DocumentNode | GraphQLSchema
  resolvers: Resolvers
}

export class GraphQL implements Sink<Input> {
  private _db: DB<unknown>
  private _express: Express
  private _types: Array<string | DocumentNode | GraphQLSchema>
  private _resolvers: Resolvers[]

  name = GraphQL.name

  constructor(server: Server, db: DB<unknown>) {
    this._db = db
    this._express = server.express
    this._types = []
    this._resolvers = []
  }

  getInputExample(): Input {
    return {
      types: `
        type Query {
          name: String
        }
      `,
      resolvers: {
        Query: {
          name: () => 'John Doe'
        }
      }
    }
  }

  async write(data: Input[]): Promise<number> {
    let added = 0
    for (const item of data) {
      this._types.push(item.types)
      this._resolvers.push(item.resolvers)
      added++
    }
    return added
  }

  add(source: Source<unknown>): void {
    const typeName = getTypeName(source)
    const fieldName = getFieldName(source)

    const sourceTypes = getTypes(source)

    const defaultParams = getDefaultParams()
    const sourceParams = getSourceParams(source)

    const params = [...defaultParams, ...sourceParams]

    const expanded = params.map((param) => `${param.name}: ${param.type}`).join(', ')
    const rootType = `
      type Query {
        ${fieldName}(${expanded}): [${typeName}]
      }
    `

    const resolvers = {
      Query: {
        [fieldName]: (_: unknown, args: ResolverArguments) => {
          const klass = source
          const filters = args
          const limit = args.limit
          return this._db.read({ klass, filters, limit })
        }
      }
    }

    this._types.push(rootType)
    this._types.push(sourceTypes)
    this._resolvers.push(resolvers)
  }

  setup(): void {
    // Default to the `Input` example if no types are given
    if (this._types.length === 0) {
      const { types, resolvers } = this.getInputExample()
      this._types.push(types)
      this._resolvers.push(resolvers)
    }
    const typeDefs = mergeTypeDefs(this._types)
    const resolvers = mergeResolvers(this._resolvers)
    const server = new ApolloServer({ typeDefs, resolvers })
    server.applyMiddleware({ app: this._express })
  }
}

function getFieldName(klass: Klass): string {
  return toCamelCase(klass.name)
}

function getTypeName(klass: Klass): string {
  return toPascalCase(klass.name)
}

function getTypes(source: Source<unknown>): string {
  const prefix = getTypeName(source)
  const example = source.getOutputExample()

  const { value } = jsonToSchema({ jsonInput: JSON.stringify(example) })

  // Matches patterns like `type FooBar {`
  const typeNameRegex = new RegExp('type ([A-Z]{1}.*)+\\s{', 'g')

  let matched
  let result = value
  while ((matched = typeNameRegex.exec(result))) {
    const oldTypeName = matched[1]

    let newTypeName = prefix + oldTypeName
    if (oldTypeName === 'AutogeneratedMainType') {
      newTypeName = prefix
    }

    const oldTypeNameRegex = new RegExp(`\\s${oldTypeName}\\s`, 'g')
    result = result.replace(oldTypeNameRegex, ` ${newTypeName} `)
  }

  return result
}

function getDefaultParams(): Parameter[] {
  const result: Parameter[] = []

  result.push({
    name: 'limit',
    type: 'Int!'
  })

  return result
}

function getSourceParams(source: Source<unknown>): Parameter[] {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const example = source.getOutputExample() as any

  const result: Parameter[] = []
  for (const [key, value] of Object.entries(example)) {
    if (typeof value === 'string') {
      result.push({
        name: key,
        type: 'String'
      })
    } else if (typeof value === 'number' && Number.isInteger(value)) {
      result.push({
        name: key,
        type: 'Int'
      })
    } else if (typeof value === 'number' && !Number.isInteger(value)) {
      result.push({
        name: key,
        type: 'Float'
      })
    } else if (typeof value === 'boolean') {
      result.push({
        name: key,
        type: 'Boolean'
      })
    }
  }

  return result
}

type Parameter = {
  name: string
  type: 'String' | 'String!' | 'Int' | 'Int!' | 'Float' | 'Float!' | 'Boolean' | 'Boolean!'
}

type ResolverArguments = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  filters: any
  limit: number
}

type Resolvers = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [key: string]: any
}
