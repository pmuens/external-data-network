import { Express } from 'express'
import { ApolloServer } from 'apollo-server-express'
import { DocumentNode, GraphQLSchema } from 'graphql'
import { mergeTypeDefs, mergeResolvers } from '@graphql-tools/merge'
import { jsonToSchema } from '@walmartlabs/json-to-simple-graphql-schema'

import { DB } from './db'
import { Server } from './server'
import { Klass } from './types'
import { toPascalCase, toCamelCase } from './shared'
import { Source, Sink } from './interfaces'

export type Input = {
  types: string | DocumentNode | GraphQLSchema
  resolvers: Resolvers
}

export class GraphQL implements Sink<Input> {
  private _db: DB<unknown>
  private _express: Express
  private _types: Array<string | DocumentNode | GraphQLSchema>
  private _resolvers: Resolvers[]

  name = GraphQL.name

  constructor(server: Server, db: DB<unknown>) {
    this._db = db
    this._express = server.express
    this._types = []
    this._resolvers = []
  }

  async write(_: Klass, data: Input[]): Promise<number> {
    let added = 0
    for (const item of data) {
      this._types.push(item.types)
      this._resolvers.push(item.resolvers)
      added++
    }
    return added
  }

  add(source: Source<unknown>): void {
    const typeName = getTypeName(source)
    const fieldName = getFieldName(source)

    const sourceTypes = getTypes(source)

    const rootTypeName = 'Query'
    let rootType = `type ${rootTypeName} { ${fieldName}: [${typeName}]}`
    const params = getParams(source)
    if (params.length) {
      const expanded = params.map((param) => `${param.name}: ${param.type}`).join(', ')
      rootType = `type ${rootTypeName} { ${fieldName}(${expanded}): [${typeName}]}`
    }

    const resolvers = {
      [rootTypeName]: {
        [fieldName]: (_: unknown, args: unknown) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return this._db.read({ klass: source, filters: args as any })
        }
      }
    }

    this._types.push(rootType)
    this._types.push(sourceTypes)
    this._resolvers.push(resolvers)
  }

  setup(): void {
    const typeDefs = mergeTypeDefs(this._types)
    const resolvers = mergeResolvers(this._resolvers)
    const server = new ApolloServer({ typeDefs, resolvers })
    server.applyMiddleware({ app: this._express })
  }
}

function getFieldName(klass: Klass): string {
  return toCamelCase(klass.name)
}

function getTypeName(klass: Klass): string {
  return toPascalCase(klass.name)
}

function getTypes(source: Source<unknown>): string {
  const prefix = getTypeName(source)
  const example = source.getOutputExample()

  const { value } = jsonToSchema({ jsonInput: JSON.stringify(example) })

  // Matches patterns like `type FooBar {`
  const typeNameRegex = new RegExp('type ([A-Z]{1}.*)+\\s{', 'g')

  let matched
  let result = value
  while ((matched = typeNameRegex.exec(result))) {
    const oldTypeName = matched[1]

    let newTypeName = prefix + oldTypeName
    if (oldTypeName === 'AutogeneratedMainType') {
      newTypeName = prefix
    }

    const oldTypeNameRegex = new RegExp(`\\s${oldTypeName}\\s`, 'g')
    result = result.replace(oldTypeNameRegex, ` ${newTypeName} `)
  }

  return result
}

function getParams(source: Source<unknown>): Parameter[] {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const example = source.getOutputExample() as any

  const result: Parameter[] = []
  for (const [key, value] of Object.entries(example)) {
    if (typeof value === 'string') {
      result.push({
        name: key,
        type: 'String'
      })
    } else if (typeof value === 'number' && Number.isInteger(value)) {
      result.push({
        name: key,
        type: 'Int'
      })
    } else if (typeof value === 'number' && !Number.isInteger(value)) {
      result.push({
        name: key,
        type: 'Float'
      })
    } else if (typeof value === 'boolean') {
      result.push({
        name: key,
        type: 'Boolean'
      })
    }
  }

  return result
}

type Parameter = {
  name: string
  type: 'String' | 'Int' | 'Float' | 'Boolean'
}

type Resolvers = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [key: string]: any
}
